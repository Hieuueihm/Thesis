

/*  pl-mrelbp-driver.c - The simplest kernel module.

* Copyright (C) 2013 - 2016 Xilinx, Inc
*
*   This program is free software; you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation; either version 2 of the License, or
*   (at your option) any later version.

*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License along
*   with this program. If not, see <http://www.gnu.org/licenses/>.

*/

#include <linux/module.h>
#include <linux/version.h>

#include <linux/kernel.h>
#include <linux/slab.h>
#include <linux/io.h>
#include <linux/interrupt.h>

#include <linux/init.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/of.h>
#include <linux/of_address.h>
#include <linux/of_platform.h>
#include <linux/platform_device.h>
#include <linux/delay.h>
#include <linux/dmaengine.h>
#include <linux/dma-mapping.h>
#include <linux/ioctl.h>


MODULE_LICENSE("GPL");
MODULE_AUTHOR("Xilinx Inc.");
MODULE_DESCRIPTION("pl-led-driver - loadable module template generated by petalinux-create -t modules");
static struct dma_chan *tx_chan;
static struct dma_chan *rx_chan;
static struct completion tx_cmp;
static struct completion rx_cmp;
static dma_cookie_t tx_cookie;
static dma_cookie_t rx_cookie;
static dma_addr_t tx_dma_handle;
static dma_addr_t rx_dma_handle;
#define DRIVER_NAME "pl-mrelbp-driver"

#define DMA_BASE_ADDR  0xA0000000
#define DMA_REG_SIZE       0x1000

#define GPIO_BASE_ADDR     0xA0001000
#define GPIO_REG_SIZE      0x1000



#define MM2S_CTRL_OFFSET    0x00
#define MM2S_STATUS_OFFSET  0x04
#define MM2S_SRC_ADDR       0x18
#define MM2S_LENGTH         0x28


#define S2MM_CTRL_OFFSET    0x30
#define S2MM_STATUS_OFFSET  0x34
#define S2MM_DEST_ADDR      0x48
#define S2MM_LENGTH         0x58

#define GPIO_DATA_OFFSET   (0x0)    /* Data register  */
#define GPIO_TRI_OFFSET    (0x4)    /* I/O direction register  */

#define BUF_SIZE_INP 128 * 128
#define BUF_SIZE_OUP 600

static void __iomem *gpio_regs;


static void *src_buf;
static dma_addr_t src_phys;

static void *dst_buf;
static dma_addr_t dst_phys;


static dev_t devt;
static struct cdev cdev;
static struct class *pl_class;
static int device_open(struct inode *inode, struct file *file) {
    return 0;
}

static int device_release(struct inode *inode, struct file *file) {
    return 0;
}

static void gpio_set_direction_output(void) {
    iowrite32(0x0, gpio_regs + GPIO_TRI_OFFSET);  // SET AS OUPUT
}
static void gpio_write(u32 val){
      iowrite32(val, gpio_regs + GPIO_DATA_OFFSET); // WRITE DATA TO IT
}

// static long device_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {
//     int i;

//     switch (cmd) {
//     case CMD_GPIO_START:
//       gpio_set_direction_output();
//      gpio_write(1);
//      ndelay(10);
//      gpio_write(0);
//      break;
//     case CMD_DMA_RESET:

//      //Reset DMA
//      iowrite32(0x4, dma_regs + S2MM_CTRL_OFFSET);
//      iowrite32(0x4, dma_regs + MM2S_CTRL_OFFSET);
//      break;
//     case CMD_DMA_TRANSFER:
//      for (i = 0; i < BUF_SIZE_INP; i++)
//         ((u8 *)src_buf)[i] = i & 0xFF;


//      iowrite32(0x1, dma_regs + MM2S_CTRL_OFFSET);
//      iowrite32(0x1, dma_regs + S2MM_CTRL_OFFSET);

//      // Set addresses
//      iowrite32((u32)src_phys, dma_regs + MM2S_SRC_ADDR);
//      iowrite32((u32)dst_phys, dma_regs + S2MM_DEST_ADDR);

//       iowrite32(BUF_SIZE_INP, dma_regs + MM2S_LENGTH);
//      iowrite32(BUF_SIZE_OUP, dma_regs + S2MM_LENGTH);

//         break;

//     case CMD_GET_RESULT:
//       while (!(ioread32(dma_regs + MM2S_STATUS_OFFSET) & 0x1)); // check halted
//      while (!(ioread32(dma_regs + S2MM_STATUS_OFFSET) & 0x1));
//      printk(KERN_INFO "DMA Done. Output:\n");
//      for (i = 0; i < 16; i++)
//          printk(KERN_INFO "dst[%d] = %02X\n", i, ((u8 *)dst_buf)[i]);
//         break;

//     case CMD_CLEAR_BUFFER:
//      memset(src_buf, 0, BUF_SIZE_INP);
//         memset(dst_buf, 0, BUF_SIZE_OUP);
//         printk(KERN_INFO "DMA Buffers cleared.\n");
//         break;

//     default:
//         return -EINVAL; 
//  }

   


//     return 0;
// }
static ssize_t write_from_user_app(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
{
    if (count > BUF_SIZE_INP)
        return -EINVAL;

    if (copy_from_user(src_buf, buf, count))
        return -EFAULT;

    printk(KERN_INFO "Received %zu bytes from user\n", count);
    return count;
}
static struct file_operations fops = {
    .owner = THIS_MODULE,
    // .unlocked_ioctl = device_ioctl,
    .open = device_open,
    .release = device_release,
     .write = write_from_user_app
};

static int pl_init(void){
    int ret;
    struct device *dev;
    // mapping address
    gpio_regs = ioremap(GPIO_BASE_ADDR, GPIO_REG_SIZE);
    if (!gpio_regs) {
        printk(KERN_ERR "Failed to map IO memory\n");
        return -ENOMEM;
    }
    dma_cap_mask_t mask;
    dma_cap_zero(mask);
    dma_cap_set(DMA_SLAVE, mask);
    dma_cap_set(DMA_PRIVATE, mask);

    printk(KERN_INFO "AXI DMA module initialized\n");

        tx_chan = dma_request_channel(mask, NULL, NULL);
    rx_chan = dma_request_channel(mask, NULL, NULL);

    if (!rx_chan || !tx_chan) { 
        printk(KERN_INFO "DMA channel request error\n");
        return -1;
    }
    
    printk(KERN_INFO "AXI DMA module success\n");


    // register char device
     ret = alloc_chrdev_region(&devt, 0, 1, DRIVER_NAME);
    if (ret)
        return ret;

     cdev_init(&cdev, &fops);
    ret = cdev_add(&cdev, devt, 1);
    if (ret)
    pl_class = class_create(THIS_MODULE, DRIVER_NAME);
    if (IS_ERR(pl_class))
        return PTR_ERR(pl_class);

    dev = device_create(pl_class, NULL, devt, NULL, DRIVER_NAME);

    printk(KERN_INFO DRIVER_NAME ": Driver initialized.\n");
    return 0;
}
static const struct of_device_id rfx_axidmatest_of_ids[] = {
	{ .compatible = "xlnx,axi-dma-test-1.00.a",},
	{}
};

static struct platform_driver rfx_axidmatest_driver = {
	.driver = {
		.name = "rfx-axidma",
		.owner = THIS_MODULE,
		.of_match_table = rfx_axidmatest_of_ids,
	},
	.probe = xilinx_axidmatest_probe,
	.remove = xilinx_axidmatest_remove,
};

static int xilinx_axidmatest_probe(struct platform_device *pdev)
{

    int err;
    dma_cap_mask_t mask;
    
    /* Step 1, zero out the capability mask then initialize
	 * it for a slave channel that is private
	 */
    dma_cap_zero(mask);
	dma_cap_set(DMA_SLAVE | DMA_PRIVATE, mask);
    

    /* Step 2, request the transmit and receive channels for the AXI DMA
	 * from the DMA engine
	 */

    //    struct dma_chan *tx_chan, *rx_chan;

    
	tx_chan = dma_request_slave_channel(&pdev->dev, "dma0");
	if (IS_ERR(tx_chan)) {
		pr_err("xilinx_dmatest: No Tx channel\n");
		return PTR_ERR(tx_chan);
	}

	rx_chan = dma_request_slave_channel(&pdev->dev, "dma1");
	if (IS_ERR(rx_chan)) {
		err = PTR_ERR(rx_chan);
		pr_err("xilinx_dmatest: No Rx channel\n");
		goto free_tx;
	}

    //	err = dmatest_add_slave_channels(tx_chan, rx_chan);
    //	if (err) {
    //		pr_err("xilinx_dmatest: Unable to add channels\n");
    //		goto free_rx;
    //	}
    
    
    axidma_test_transfer();
	return 0;

free_rx:
	dma_release_channel(rx_chan);
free_tx:
	dma_release_channel(tx_chan);

	return 0;
}

static int xilinx_axidmatest_remove(struct platform_device *pdev)
{
	struct dmatest_chan *dtc, *_dtc;
	struct dma_chan *chan;

    /* Step 12, release the DMA channels back to the DMA engine
	 */
    
    dma_release_channel(tx_chan);
    dma_release_channel(rx_chan);
    
//	list_for_each_entry_safe(dtc, _dtc, &dmatest_channels, node) {
//		list_del(&dtc->node);
//		chan = dtc->chan;
//		dmatest_cleanup_channel(dtc);
//		pr_info("xilinx_dmatest: dropped channel %s\n",
//			dma_chan_name(chan));
//		dma_release_channel(chan);
//	}
	return 0;
}

static void   pl_exit(void){
    printk(KERN_INFO "AXI DMA module exited\n");

    // device_destroy(pl_class, devt);
    // class_destroy(pl_class);
    cdev_del(&cdev);
    unregister_chrdev_region(devt, 1);



    iounmap(gpio_regs);

    printk(KERN_INFO DRIVER_NAME ": Driver removed.\n");
}


module_init(pl_init);
module_exit(pl_exit);
